# Naming 命名

## General conventions  通用的约定


Apple naming conventions should be adhered to wherever possible, especially those related to [memory management rules](https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html) ([NARC](http://stackoverflow.com/a/2865194/340508)).

尽可能遵守 Apple 的命名约定，尤其是和 [内存管理规则](https://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html) ([NARC](http://stackoverflow.com/a/2865194/340508)) 相关的地方。

Long, descriptive method and variable names are good.

推荐使用长的、描述性的方法和变量名

**Preferred:**

```objective-c
UIButton *settingsButton;
```

**Not Preferred:**
```objective-c
UIButton *setBut;
```

## Constants 常量

Constants should be camel-case with all words capitalized and prefixed by the related class name for clarity.

常量应该使用驼峰命名法，并且为了清楚，应该用相关的类名作为前缀。

**Preferred:**
```objective-c
static const NSTimeInterval ZOCSignInViewControllerFadeOutAnimationDuration = 0.4;
```

**Not Preferred:**
```objective-c
static const NSTimeInterval fadeOutTime = 0.4;
```

Constants are preferred over in-line string literals or numbers, as they allow for easy reproduction of commonly used variables and can be quickly changed without the need for find and replace. Constants should be declared as `static` constants and not `#define`s unless explicitly being used as a macro.

常量尽量应该使用 in-line 的字符串和数字， as they allow for easy reproduction of commonly used variables and can be quickly changed without the need for find and replace。 常量应该用 `static` 声明，并且不要用 `#define`，除非它是用作一个宏。

**Preferred:**
```objective-c
static NSString * const ZOCCacheControllerDidClearCacheNotification = @"ZOCCacheControllerDidClearCacheNotification";
static const CGFloat ZOCImageThumbnailHeight = 50.0f;
```

**Not Preferred:**

```objective-c
#define CompanyName @"Apple Inc."
#define magicNumber 42
```

Constants exposed externally should use this pattern in the interface file:

常量应该在 interface 文件中这样被暴露

```objective-c
extern NSString *const ZOCCacheControllerDidClearCacheNotification;
```
and the previously defined assignment should be in the implementation file.

并且之前的定义语句应该在实现文件中。

You only need to add the namespace to a constant that is made public. Even though constants used within an implementation could follow a different pattern, there is no need not to be consistent with the rule.

你只需要为 public 的常量添加命名空间。Even though constants used within an implementation could follow a different pattern, there is no need not to be consistent with the rule.

## Methods 方法
 
In method signatures, there should be a space after the method type (`-`/`+` symbol). There should be a space between the method segments (matching Apple's style).  Always include a keyword and be descriptive with the word before the argument which describes the argument.

对于方法签名，在方法类型 (`-`/`+` 符号)后应该要有一个空格。方法段之间也应该有一个空格（符合 Apple 的规范）。在参数名称之前总是应该有一个描述性的关键词。

The usage of the word "and" is reserved.  It should not be used for multiple parameters as illustrated in the `initWithWidth:height:` example below.

“and”这个单词的使用应该保留。它不应该用作阐明有多个参数 比如下面的`initWithWidth:height:` 例子：

**Preferred:**
```objective-c
- (void)setExampleText:(NSString *)text image:(UIImage *)image;
- (void)sendAction:(SEL)aSelector to:(id)anObject forAllCells:(BOOL)flag;
- (id)viewWithTag:(NSInteger)tag;
- (instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height;
```

**Not Preferred:**

```objective-c
- (void)setT:(NSString *)text i:(UIImage *)image;
- (void)sendAction:(SEL)aSelector :(id)anObject :(BOOL)flag;
- (id)taggedView:(NSInteger)tag;
- (instancetype)initWithWidth:(CGFloat)width andHeight:(CGFloat)height;
- (instancetype)initWith:(int)width and:(int)height;  // Never do this.
```

## Literals 字面值

`NSString`, `NSDictionary`, `NSArray`, and `NSNumber` literals should be used whenever creating immutable instances of those objects. Pay special care that `nil` values not be passed into `NSArray` and `NSDictionary` literals, as this will cause a crash.



`NSString`, `NSDictionary`, `NSArray`, 和 `NSNumber` 字面值应该用在任何创建不可变的实例对象。特别小心 `nil` 不能放进 `NSArray` 和 `NSDictionary` 里，这会导致 Crash。

**For example:**

```objective-c
NSArray *names = @[@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul"];
NSDictionary *productManagers = @{@"iPhone" : @"Kate", @"iPad" : @"Kamal", @"Mobile Web" : @"Bill"};
NSNumber *shouldUseLiterals = @YES;
NSNumber *buildingZIPCode = @10018;
```

**Not:**

```objective-c
NSArray *names = [NSArray arrayWithObjects:@"Brian", @"Matt", @"Chris", @"Alex", @"Steve", @"Paul", nil];
NSDictionary *productManagers = [NSDictionary dictionaryWithObjectsAndKeys: @"Kate", @"iPhone", @"Kamal", @"iPad", @"Bill", @"Mobile Web", nil];
NSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];
NSNumber *buildingZIPCode = [NSNumber numberWithInteger:10018];
```

For the mutable counterparts of these classes we recommend, instead, the use of the explicit classes such as `NSMutableArray`, `NSMutableString`, and so on. 

对于那些可变的副本，我们推荐使用明确的如`NSMutableArray`, `NSMutableString`这些类。

The following **should be avoided**:

下面的   **应该被避免**:

```objective-c
NSMutableArray *aMutableArray = [@[] mutableCopy];
```

The problems with the previous notation are both of efficiency and readability. 
On the efficiency side, an unnecessarily immutable object is created and immediately thrown away; this unlikely will slow down your app (unless the method here is called frequently) but there is really no reason to do this just to save some characters. 
Regarding the readability, we can see two problems here: the first is that when scanning through the code and seeing `@[]` your mind is immediately connected to and instance of `NSArray`, but in this case you need to stop and check more thoughtfully. Another aspect to take into account is that it would be very likely that someone with less experience will see your code and depending on his background he might not be very comfortable with the dichotomy between mutable and immutable objects. He or she could not be very familiar with the meaning of creating a mutable copy (obviously we are not suggesting that this knowledge is not necessary). Again, this is not something absolutely wrong but is more about code usability (that includes readability).

